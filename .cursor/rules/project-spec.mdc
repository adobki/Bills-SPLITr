---
description: Core rules, conventions, and architectural guidelines for Bills SPLITr app project.
globs:
alwaysApply: true
---

## Project Overview: Bills SPLITr is a user-friendly mobile app designed to simplify shared expenses. Whether you’re dining out with friends, splitting rent with roommates, or managing group activities, this app calculates each person’s share instantly. It also automatically factors in taxes and tips if included, allowing for accurate, stress-free bill splitting. The interface is clean and intuitive, making it accessible even to users with minimal tech experience. The results can be shared by copying to the clipboard or sharing unique links directly, via social media, or QR codes.

Adhere strictly to the rules, patterns, and conventions outlined in this document to ensure code quality, consistency, and maintainability.

## Technology Stack
The project uses the following technologies. Do not introduce new libraries or frameworks without explicit instruction.

- Language: TypeScript
- Main Framework: React (with Vite)
- Database & Auth: Supabase
- Styling: Tailwind CSS with shadcn/ui components, Recharts for pie/bar charts in Bill Details, and Framer Motion for smooth transitions (modals, item lists, etc.)
- State and Data Handling: Supabase (Primary Data layer) - Postgres DB for bills, items, and participants; realtime subscriptions if we implement collaborative editing later; Supabase client handles data fetching and mutation directly in React. React Query (TanStack Query) for data fetching + caching - Handles async state (loading, error, stale vs fresh); pairs perfectly with Supabase SDK.
- Utility Libraries: A library like qrcode.react for generating QR codes.
- Testing: Jest + React Testing Library for unit/component testing, and Playwright (optional) for end-to-end/integration testing for flows like “create bill → add items → share.”

## Architecture & Code Style
- **Operating System Support:** The project is developed and tested primarily on Windows OS. When writing documentation or scripts, use Windows-style paths (e.g., `.\app\page.tsx`) and commands. Always check the current working directory before running terminal commands to avoid unnecessary path prefixes.

- Directory Structure: Follow the standard React/Vite App Router structure, with `\src` as the root folder.
    - `\app` for routes and pages.
    - `\components\ui` for `shadcn\ui` components.
    - `\components\` for custom, reusable components.
    - `\lib` for Supabase client setup, utility functions, and Server Actions.

- Naming Conventions: Component files should be PascalCase (CreateBillForm.tsx). Utility and action functions should be camelCase (submitBill.ts).
- Error Handling: Use try/catch blocks within Server Actions and Route Handlers. Use Next.js error.tsx files for handling errors within route segments.
- API Keys & Secrets: Never hardcode secrets. Use environment variables (.env.local) for Supabase URL and keys, accessed via process.env.NEXT_PUBLIC_SUPABASE_URL and process.env.SUPABASE_SECRET_KEY.

## Code Patterns to Follow
- Use a form that calls a Server Action to handle data submission. This keeps client-side JavaScript minimal.
- Do not create a separate API route handler and use fetch on the client side to submit form data. Use Server Actions instead.
- Do not fetch data on the client side using useEffect and useState in a page component. Fetch data directly in a Server Component.

## Verification Checklist
Before finalizing your response, you MUST verify the following:
- Does the code use the Next.js App Router and Server Components for data fetching?
- Are Server Actions used for data mutations (forms)?
- Is the Supabase client used for all database interactions?
- Are shadcn/ui components used for the UI where appropriate?
- Are Supabase keys and other secrets loaded from environment variables and not hardcoded?

## Developer Notes
- **Routing:** Bills List is root → all other screens branch from it.
- **Modals:** Add People + Share = overlay components, not full navigations.
- **UX Priority:** Reduce friction → no required participants, bill name optional.

## Rules Status / Validation
Never do these unannounced. Always ask permission first and provide justification if you feel the need to do them:
- Never import a new package unless to prevent random package import errors, unless there is a justification for why you need the new import and can't just code the function instead.
- Do not remove lines that have nothing to do with your current changes.
- Do not randomly/needlessly reimport things that have already been imported.

## Database Schema Tables (Supabase – Postgres)
1. `users` (Supabase provides this automatically if you enable Auth)
    - `id` (uuid, PK)
    - `email` (text, unique)
    - `name` (text, optional)
    - `created_at` (timestamp)

2. `bills`
    - `id` (uuid, PK)
    - `title` (text, required)
    - `total_amount` (numeric, computed or stored)
    - `created_by` (uuid, FK → users.id)
    - `created_at` (timestamp)

3. `participants`
    - `id` (uuid, PK)
    - `name` (text, required)
    - `bill_id` (uuid, FK → bills.id, cascade delete)
    - `created_at` (timestamp)

4. `items`
    - `id` (uuid, PK)
    - `bill_id` (uuid, FK → bills.id, cascade delete)
    - `name` (text, required)
    - `cost` (numeric, required)
    - `created_at` (timestamp)

5. `item_assignments` (many-to-many: which participants are responsible for which item)
    - `id` (uuid, PK)
    - `item_id` (uuid, FK → items.id, cascade delete)
    - `participant_id` (uuid, FK → participants.id, cascade delete)
    - `share` (numeric, optional, defaults to equal split)

Notes
1. `bills.total_amount` can be a computed field (sum of items.cost) or updated via triggers.
2. `item_assignments.share` allows flexibility:
    - Equal split (default, system-calculated).
    - Custom percentages/amounts (user override)

## Development Plan (Step-by-Step)
### Build Order Summary
**Phase 1:** Setup project + DB schema + routing.
**Phase 2:** Implement full CRUD for bills, items, participants, assignments.
**Phase 3:** Sharing + delete + charts (core UX complete).
**Phase 4:** Auth + realtime + polish (portfolio extras).

### **Phase 1:** Setup & Scaffolding
1. Project bootstrap
    - Init React (Vite) project.
    - Add Tailwind + shadcn/ui + Framer Motion.
    - Configure file structure (components, pages, hooks, utils).

2. Supabase setup
    - Create project in Supabase.
    - Define tables from schema above.
    - Connect Supabase client SDK in React.

3. Routing & Navbar
    - Install React Router.
    - Setup base routes: /, /bills/:id, /share/:id (as per wireframes in README.md).
    - Add navbar (back button, share button, etc. as per wireframes in README.md).
    - Add 404 page for unregistered/miscellaneous routes.

### **Phase 2:** Core Bill Flow
4. Welcome / Bills List screen
    - Fetch & display user’s bills (or demo bills if auth not enabled yet).
    - “+ Add Bill” CTA → opens Add Bill screen.

5. Add Bill screen
    - Create a bill (title).
    - Save to Supabase.
    - Redirect back to list.

6. Bill Details screen (items + participants)
    - Add/Delete items (name, cost).
    - Add/Delete participants.
    - Realtime updates (optional).

7. Assignments logic
    - Add participants to items.
    - Calculate per-person totals.
    - Display summary list under chart.

### **Phase 3:** Sharing & UX Polish
8. Share screen/modal
    - Display summary of who owes what.
    - Add button to copy/share link.
    - Future: generate QR code with share link.

9. Delete actions
    - Enable delete for items, participants, and entire bill.
    - Confirm before delete.

10. Charts integration
    - Recharts: Pie chart (share by participant), Bar chart (expenses by item).

### **Phase 4:** Roadmap Enhancements
11. Authentication (Supabase Auth)
    - Enable email login / magic link.
    - Bills tied to user accounts.

12. Multi-user collaboration (optional)
    - Realtime Supabase subscriptions → multiple people editing the same bill.

13. Polish
    - Dark mode toggle.
    - Mobile PWA support.
    - Export/share as PDF or CSV.
